# 线段树

## [模板](https://www.luogu.com.cn/problem/P3372)

线段树。已知一个数列，你需要进行下面两种操作：

* 将某区间每一个数加上 𝑘。
* 求出某区间每一个数的和。

```cpp
#include "bits/stdc++.h"
using namespace std;

using ll = long long;

struct STN { ll val, lazy; };
struct ST {
    ll n;
    vector<STN> a;
    ST(ll n) : n(n), a(vector<STN>(n * 4)) {};

    void increase(ll l, ll r, ll d) { increase(1, 1, n, l, r, d); }
    void increase(ll k, ll l, ll r, ll L, ll R, ll D) {
        if (L <= l && r <= R) {
            a[k].val += (r - l + 1) * D, a[k].lazy += D;
            return;
        }
        pushdown(k, l, r);
        ll lc = k << 1, rc = lc | 1, m = (l + r) >> 1;
        if (m >= L) increase(lc, l, m, L, R, D);
        if (R >= m+1) increase(rc, m+1, r, L, R, D);
        pushup(k);
    }
    void pushdown(ll k, ll l, ll r) {
        auto &lazy = a[k].lazy;
        if (!lazy) return;
        ll lc = k << 1, rc = lc | 1, m = (l + r) >> 1;
        a[lc].lazy += lazy, a[lc].val += (m - l + 1) * lazy;
        a[rc].lazy += lazy, a[rc].val += (r - (m+1) + 1) * lazy;
        lazy = 0;
    }
    void pushup(ll k) {
        ll lc = k << 1, rc = lc | 1;
        a[k].val = a[lc].val + a[rc].val;
    }
    ll query(ll l, ll r) { return query(1, 1, n, l, r); }
    ll query(ll k, ll l, ll r, ll L, ll R) {
        if (L <= l && r <= R) return a[k].val;
        pushdown(k, l, r);
        ll lc = k << 1, rc = lc | 1, m = (l + r) >> 1, ans = 0;
        if (m >= L) ans += query(lc, l, m, L, R);
        if (R >= m+1) ans += query(rc, m+1, r, L, R);
        return ans;
    }
};

int main() {
    int n, m; cin >> n >> m;    
    ST st(n);
    for (int i = 1, t; i <= n; i++) cin >> t, st.increase(i, i, t);    
    while (m--) {
        int op, x, y, k; cin >> op;
        if (op == 1) {
            cin >> x >> y >> k; st.increase(x, y, k);
        } else {
            cin >> x >> y; cout << st.query(x, y) << endl;
        }
    }
}
```

动态开点线段树，数组实现。

```cpp
#include "bits/stdc++.h"
using namespace std;

using ll = long long;
static const int mxn = 5 * 1e5;

struct STN {
    ll val, lazy, lc, rc;
    STN() : val(0), lazy(0), lc(0), rc(0) {}
};
struct ST {
    ll n, cnt;
    vector<STN> a;
    ST(ll n) : n(n), cnt(2), a(vector<STN>(mxn * 2, STN())) {};

    ll newnode() { return cnt++;
    }
    void increase(ll l, ll r, ll d) {
        ll k = 1;
        increase(k, 1, n, l, r, d);
    }
    inline void increase(ll &k, ll l, ll r, ll L, ll R, ll D) {
        if (!k) k = newnode();
        if (L <= l && r <= R) {
            a[k].val += (r - l + 1) * D, a[k].lazy += D;
            return;
        }
        pushdown(k, l, r);
        ll m = (l + r) >> 1;
        if (m >= L) increase(a[k].lc, l, m, L, R, D);
        if (R >= m+1) increase(a[k].rc, m+1, r, L, R, D);
        pushup(k);
    }
    inline void pushdown(ll &k, ll l, ll r) {
        auto &lazy = a[k].lazy;
        if (!lazy) return;
        ll &lc = a[k].lc, &rc = a[k].rc, m = (l + r) >> 1;
        if (!lc) lc = newnode();
        if (!rc) rc = newnode();
        a[lc].lazy += lazy, a[lc].val += (m - l + 1) * lazy;
        a[rc].lazy += lazy, a[rc].val += (r - (m+1) + 1) * lazy;
        lazy = 0;
    }
    inline void pushup(ll &k) {
        ll lc = a[k].lc, rc = a[k].rc;
        a[k].val = a[lc].val + a[rc].val;
    }
    ll query(ll l, ll r) {
        ll k = 1;
        return query(k, 1, n, l, r); 
    }
    inline ll query(ll &k, ll l, ll r, ll L, ll R) {
        if (!k) return 0;
        if (L <= l && r <= R) return a[k].val;
        pushdown(k, l, r);
        ll m = (l + r) >> 1, ans = 0;
        if (m >= L) ans += query(a[k].lc, l, m, L, R);
        if (R >= m+1) ans += query(a[k].rc, m+1, r, L, R);
        return ans;
    }
};

int main() {
    int n, m; cin >> n >> m;    
    ST st(n);
    for (int i = 1, t; i <= n; i++) cin >> t, st.increase(i, i, t);    
    while (m--) {
        int op, x, y, k; cin >> op;
        if (op == 1) {
            cin >> x >> y >> k; st.increase(x, y, k);
        } else {
            cin >> x >> y; cout << st.query(x, y) << endl;
        }
    }
}
```

