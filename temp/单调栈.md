# 单调栈 (monolithic stack)

每次入栈前，删掉栈顶更大/小的元素，再入栈，栈内保持单调的性质。典型题目：找每个数字左边或者右边第一个比它大或者小的数字。

以单调递增为例：

* [入栈更新答案] 每个元素会入栈一次。入栈前比它大的元素都删掉了，所以最终栈顶的元素就是它左边第一个比它小的元素。

* [出栈更新答案] 部分元素会出栈一次，剩余元素不会出栈。入栈时，弹出的是比当前元素大的元素，所以当前元素是出栈元素右边第一个比它小的元素。剩余元素没有右边更大的元素了。

## [下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/description/)

没有重复的数组num中，求nums1每个元素在nums2下的位置的下一个比它更大的数字。

哈希表继续num2里每个元素下一个更大的元素，查询nums1中的数字得到答案。

```cpp
vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
    unordered_map<int, int> m;
    int n = nums2.size();
    stack<int> s;
    for (auto i : nums2) {
        while (!s.empty() && s.top() < i) m[s.top()] = i, s.pop();
        s.push(i);
    }

    vector<int> ans;
    for (auto i : nums1) ans.push_back(m.count(i) ? m[i] : -1);
    return ans;
}
```

## [下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/description/)

给定循环数组，求每个元素下一个更大元素。

将数组复制一份，把循环数组转化为普通数组，计算下一个更大元素。实现时不需要显示复制，只需计算下标即可。

```cpp
vector<int> nextGreaterElements(vector<int>& a) {
    int n = a.size();
    vector<int> ans(n, -1);
    stack<int> s;
    for (int i = 0; i < 2 * n; i++) {
        int j = i % n;            
        while (!s.empty() && a[s.top()] < a[j]) ans[s.top()] = a[j], s.pop();
        s.push(j);
    }
    return ans;
}
```

## [每日温度](https://leetcode.cn/problems/daily-temperatures/description/)

给定每天的温度，找出每个温度后面隔几天出现一个更高的温度。

求每个数字右边第一个比当前大的数字，从左往右遍历时，对于当前数字，他右边的数字还没遍历到，不可能在入栈时更新答案。可以考虑从右到左遍历，这里还是考虑从左到右遍历，不过在出栈时候更新答案。

```cpp
vector<int> dailyTemperatures(vector<int>& a) {        
    int n = a.size();
    vector<int> ans(n, 0);
    stack<int> s;
    for (int i = 0; i < n; i++) {
        while (!s.empty() && a[s.top()] < a[i]) ans[s.top()] = i - s.top(), s.pop();
        s.push(i);
    }
    return ans;
}
```

## [接雨水](https://leetcode.cn/problems/trapping-rain-water/description/)

直方图能接多少雨水。

竖着接水。考虑每根柱子，求它左边和右边最高柱子高度，这跟柱子能接的水量为 $min(max_left, max_right) - cur$ 。

也可以横着接水。从左到右扫描，每个数左边所有比它小的数字可以填充雨水，填充部分高度和宽度取决于该小数字左边一个比他大的数字（单调栈的前一个数字）和当前数字的大小。左边所有比它小的数字，等价于找左边第一个比它大的数字。

```cpp
int trap(vector<int>& height) {
    int ans = 0, n = height.size();
    stack<int> s;
    for (int i = 0; i < n; i++) {
        while (!s.empty() && height[s.top()] < height[i]) {                                
            int h = height[s.top()];
            s.pop();
            if (!s.empty()) {
                int l = s.top(), r = i;
                ans += (min(height[l], height[r]) - h) * (r - l - 1);
            }                
        }    
        s.push(i);        
    }
    return ans;
}
```

## [柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)

求直方图里的最大矩形。

扫描每一根柱子，看向左和向右最远可以延伸多长，等于求它左边和右边第一个小于它的数字。求左边小于它的数字在每个数字入栈的时候更新，求右边小于它的数字在数字出栈的时候更新。

```cpp
int largestRectangleArea(vector<int>& heights) {
    heights.push_back(0);
    int n = heights.size();
    vector<int> l(n, -1), r(n, n+1);
    stack<int> s;
    for (int i = 0; i < n; i++) {
        while (!s.empty() && heights[s.top()] > heights[i]) r[s.top()] = i, s.pop();
        if (!s.empty()) l[i] = s.top();
        s.push(i);
    }        

    int ans = 0;
    for (int i = 0; i < n; i++) ans = max(ans, heights[i] * (r[i] - l[i] - 1));
    return ans;
}
```

## [链表中的下一个更大节点](https://leetcode.cn/problems/next-greater-node-in-linked-list/description/)

求单链表中每个节点下一个更大的元素。

类似于数组求下一个更大的元素。由于长度不知道，在遍历链表的同时每次增加一个0进答案数组，等价于一开始分配长为n全为0的数组。

```cpp
vector<int> nextLargerNodes(ListNode* head) {
    vector<int> ans; stack<pii> s;
    int i = 0;
    for (ListNode *p = head; p; p = p->next, i++) {
        while (!s.empty() && s.top().second < p->val) {
            ans[s.top().first] = p->val;
            s.pop();
        }
        s.push(pii(i, p->val));
        ans.push_back(0); // 默认没有比它更大的数字
    }
    return ans;
}
```