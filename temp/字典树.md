# 字典树

## [最大异或对](https://www.acwing.com/problem/content/145/)

数组中找出异或最大的两个数的异或值。

```cpp
namespace trie {
static const int mxn = 1e5 + 10, mxm = mxn * 32;

struct node { node *son[2]; } nodes[mxm];
int tot = 0;

void insert(int x) {
	auto p = nodes;
	for (int i = 30; i >= 0; i--) {
		auto u = x >> i & 1;
		if (!p->son[u]) p->son[u] = &nodes[++tot];
		p = p->son[u];
	}
}

int max_xor(int x) {
	auto p = nodes;
	int ans = 0;
	for (int i = 30;i >= 0; i--) {
		auto u = x >> i & 1, v = u ^ 1;
		if (p->son[v]) p = p->son[v], ans = ans << 1 | 1;
		else if (p->son[u]) p = p->son[u], ans <<= 1;
		else break;
	}
	return ans;
}
}

int main() {
	int n; cin >> n;
	int a[n]; for (int i = 0; i < n; i++) cin >> a[i], trie::insert(a[i]);	
	int ans = 0;
	for(int i = 0; i < n; i++) ans = max(ans, trie::max_xor(a[i]));
	cout << ans << endl;
	return 0;
}
```


## [最大异或和]

给定一个数组和2种操作: 1） 添加一个数，2）查询一个区间[L, R]内的一个数，使得a[p] ^ a[p+1] ^ ... ^ a[n] ^ x最大，求最大值。

使用前缀和表示这个异或值，s[p-1] ^ s[n] ^ x，后两者为常数，问题转化为在区间里找一个数，其与另一个数的异或最大。

由于在[L, R]区间内寻找，R的限制通过每次在字典树添加操作时维护版本信息得到，L的限制可以在每个顶点维护一个这个顶点的最大元素下标值得到。

```cpp

```