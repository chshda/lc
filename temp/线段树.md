# 线段树

## [模板](https://www.luogu.com.cn/problem/P3372)

线段树。已知一个数列，你需要进行下面两种操作：

* 将某区间每一个数加上 𝑘。
* 求出某区间每一个数的和。

```cpp
#include "bits/stdc++.h"
using namespace std;

using ll = long long;

struct STN { ll val, lazy; };
struct ST {
    ll n;
    vector<STN> a;
    ST(ll n) : n(n), a(vector<STN>(n * 4)) {};

    void increase(ll l, ll r, ll d) { increase(1, 1, n, l, r, d); }
    void increase(ll k, ll l, ll r, ll L, ll R, ll D) {
        if (L <= l && r <= R) {
            a[k].val += (r - l + 1) * D, a[k].lazy += D;
            return;
        }
        pushdown(k, l, r);
        ll lc = k << 1, rc = lc | 1, m = (l + r) >> 1;
        if (m >= L) increase(lc, l, m, L, R, D);
        if (R >= m+1) increase(rc, m+1, r, L, R, D);
        pushup(k);
    }
    void pushdown(ll k, ll l, ll r) {
        auto &lazy = a[k].lazy;
        if (!lazy) return;
        ll lc = k << 1, rc = lc | 1, m = (l + r) >> 1;
        a[lc].lazy += lazy, a[lc].val += (m - l + 1) * lazy;
        a[rc].lazy += lazy, a[rc].val += (r - (m+1) + 1) * lazy;
        lazy = 0;
    }
    void pushup(ll k) {
        ll lc = k << 1, rc = lc | 1;
        a[k].val = a[lc].val + a[rc].val;
    }
    ll query(ll l, ll r) { return query(1, 1, n, l, r); }
    ll query(ll k, ll l, ll r, ll L, ll R) {
        if (L <= l && r <= R) return a[k].val;
        pushdown(k, l, r);
        ll lc = k << 1, rc = lc | 1, m = (l + r) >> 1, ans = 0;
        if (m >= L) ans += query(lc, l, m, L, R);
        if (R >= m+1) ans += query(rc, m+1, r, L, R);
        return ans;
    }
};

int main() {
    int n, m; cin >> n >> m;    
    ST st(n);
    for (int i = 1, t; i <= n; i++) cin >> t, st.increase(i, i, t);    
    while (m--) {
        int op, x, y, k; cin >> op;
        if (op == 1) {
            cin >> x >> y >> k; st.increase(x, y, k);
        } else {
            cin >> x >> y; cout << st.query(x, y) << endl;
        }
    }
}
```

动态开点线段树，数组实现。

```cpp
using ll = long long;
const static int mxn = 1e5 + 10;

class SegTree {
public:
    SegTree(ll mn, ll mx) : mn(mn), mx(mx), cnt(1) {}

    void increase(ll ql, ll qr, ll d) {
        function<void(ll&, ll, ll)> f = [&](ll &k, ll l, ll r) {            
            if (!k) k = ++cnt;
            if (ql <= l && r <= qr) {
                a[k].lazy += d, a[k].val += (r - l + 1LL) * d;    
            } else {
                pushdown(k, l, r);
                ll md = (l + r) >> 1;
                if (md >= ql) f(a[k].lc, l, md);
                if (md+1 <= qr) f(a[k].rc, md+1, r);
                pushup(k);
            }
        };
        ll tem = 1;
        f(tem, mn, mx);
    }

    ll query(ll ql, ll qr) {
        function<ll(ll&, ll, ll)> f = [&](ll &k, ll l, ll r) -> ll {            
            if (!k) return 0LL;
            if (ql <= l && r <= qr) return a[k].val;

            pushdown(k, l, r);
            ll md = (l + r) >> 1, ans = 0;
            if (md >= ql) ans += f(a[k].lc, l, md);
            if (md+1 <= qr) ans += f(a[k].rc, md+1, r);
            return ans;
        };
        ll tem = 1;
        return f(tem, mn, mx);
    }

private:
    ll mn, mx, cnt;
    struct SegTreeNode { ll val, lc, rc, lazy; } a[mxn<<1] =  {0};

    inline void pushup(ll k) {
        ll lc = a[k].lc, rc = a[k].rc;
        a[k].val = a[lc].val + a[rc].val;
    }

    inline void pushdown(ll k, ll l, ll r) {
        auto &lazy = a[k].lazy;
        if (!lazy) return;

        ll &lc = a[k].lc, &rc = a[k].rc;
        if (!lc) lc = ++cnt;
        if (!rc) rc = ++cnt;

        a[lc].lazy += lazy, a[rc].lazy += lazy;
        ll md = (l + r) >> 1;
        a[lc].val += (md - l + 1) * lazy;
        a[rc].val += (r - (md+1) + 1) * lazy;
        lazy = 0;
    }
};
```

