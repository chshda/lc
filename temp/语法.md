# 语法

##

```cpp
int mask = 1065233; // bit_or(1<<(i-'a')) for i in "aeiou"
int index = a & 31; // 字符a-z转化为1-26。a=65，二进制是1000001，&31取后5位刚好是1
```

## 堆/单调队列

最小堆，每次弹出的是最小的元素，堆里最大值优先，比较函数用大于进行比较。

```cpp
// 自定义比较函数f
auto cmp = [&](int x, int y) { return f(x) > f(y); };
priority_queue<int, vector<int>, decltype(cmp)> q(cmp);
```

## 位运算

```cpp
x >> i & 1 // 取出第i位
x & (~(1<<i)) // 第i位设置为0
x | (1<<i) // 第i位设置为1
```

## STL

```cpp
is_sorted(a.begin(), a.end()); // 从小到大
is_sorted(a.rbegin(), a.rend()); // 从大到小

double ans = numeric_limits<double>::max();

priority_queue<int> q; // 大根堆，大的先出队
priority_queue<int, vector<int>, greater<int>> q; // 小根堆，小的先出队
```

## 随机数
```cpp
mt19937 gen(random_device{}());
uniform_int_distribution<int> dis(1, 100);
int x = dis(gen);
```

```cpp
struct StringHash {
    string s;
    ll n, base, mod;
    vector<ll> h, qpow;

    StringHash(const string &s, ll base = 131, ll mod = 998244353) : s(s), n(s.size()), base(base), mod(mod) {
        qpow.resize(n+1); qpow[0] = 1;
        for (ll i = 1; i <= n; i++) qpow[i] = qpow[i-1] * base % mod;

        h.resize(n+1); h[0] = 0;
        for (ll i = 0, cur = 0; i < n; i++) {
            h[i+1] = cur = (cur * base + s[i] - 'a' + 1) % mod;
        }
    }

    ll hash() { return h[n]; }
    ll hash(ll i, ll j) {  // [i, j]: 0 ... i ... j ...
        return (h[j+1] - h[i] * qpow[j - i + 1] % mod + mod) % mod;
    }
};
```

## 双哈希版本字符串哈希

Stringhash two hashes

```cpp
mt19937 gen(random_device{}());
int rnd(int x, int y) { return uniform_int_distribution<int>(x, y)(gen); }

int m1 = 998244353 + rnd(0, 1e9), b1 = 233 + rnd(0, 1e3);
int m2 = 998244353 + rnd(0, 1e9), b2 = 233 + rnd(0, 1e3);

struct SH1 {
    int n, mod, base;
    vector<long long> p, h;

    SH1(string &s, int mod = 998244353, int base = 131) : n(s.size()), mod(mod), base(base) {
        p.resize(n+1, 1);
        for (long long i = 1; i <= n; i++) p[i] = p[i-1] * base % mod;

        h.resize(n+1, 0);
        for (long long i = 0; i < n; i++) h[i+1] = (h[i] * base + s[i] - 'a' + 1) % mod;
    }

    long long hash(int i, int j) {  // [i, j], 0 based
        return (h[j+1] - h[i] * p[j - i + 1] % mod + mod) % mod;
    }
};

struct SH2 {
    int n;
    SH1 h1, h2;

    SH2(string &s) : n(s.size()), h1(SH1(s, m1, b1)), h2(SH1(s, m2, b2)) {}

    long long hash() { return hash(0, n - 1); }

    long long hash(int l, int r) {  // [i, j], 0 based
        return h1.hash(l, r) * m1 + h2.hash(l, r);
    }
};
```