# çº¿æ®µæ ‘

## [æ¨¡æ¿](https://www.luogu.com.cn/problem/P3372)

çº¿æ®µæ ‘ã€‚å·²çŸ¥ä¸€ä¸ªæ•°åˆ—ï¼Œä½ éœ€è¦è¿›è¡Œä¸‹é¢ä¸¤ç§æ“ä½œï¼š

* å°†æŸåŒºé—´æ¯ä¸€ä¸ªæ•°åŠ ä¸Š ğ‘˜ã€‚
* æ±‚å‡ºæŸåŒºé—´æ¯ä¸€ä¸ªæ•°çš„å’Œã€‚

é™æ€å¼€ç‚¹ï¼Œå·¦å³å„¿å­ä¿¡æ¯é€šè¿‡ä¸‹æ ‡ç›´æ¥è®¡ç®—ã€‚

é€’å½’è¿‡ç¨‹ä¸­ï¼ŒæŸ¥è¯¢/ä¿®æ”¹çš„åŒºé—´ [L, R] ä¿æŒä¸å˜ï¼Œéå†çš„åŒºé—´ [l, r] ä¸€ç›´åœ¨äºŒåˆ†ï¼Œ

çº¿æ®µæ ‘ï¼Œæ— lazyä¼˜åŒ–ï¼Œä¸éœ€è¦pushdownï¼Œåªæœ‰pushupã€‚1e5æ•°æ®é‡ä¸€èˆ¬ä¸éœ€è¦ä¼˜åŒ–ã€‚

```cpp
using ll = long long;

struct STN { ll sum; };
struct ST {
    ll mn, mx;
    vector<STN> a;
    ST(ll mn = 0, ll mx = 1e5) : mn(mn), mx(mx), a(vector<STN>((mx - mn) * 4)){};

    void build(vector<ll> &v) { build(1, mn, mx, v); }
    void replace(ll l, ll r, ll d) { replace(1, mn, mx, l, r, d); }
    void increase(ll l, ll r, ll d) { increase(1, mn, mx, l, r, d); }
    ll query(ll l, ll r) { return query(1, mn, mx, l, r); }

    inline void build(ll k, ll l, ll r, vector<ll> &v) {
        if (l == r) { a[k] = {v[l]}; return; }
        ll lc = k << 1, rc = lc | 1, m = (l + r) >> 1;
        build(lc, l, m, v);
        build(rc, m + 1, r, v);
        pushup(k, lc, rc);
    }
    inline void replace(ll k, ll l, ll r, ll L, ll R, ll D) {
        if (l == r) { a[k].sum = (r - l + 1) * D; return; }
        ll lc = k << 1, rc = lc | 1, m = (l + r) >> 1;
        if (m >= L) replace(lc, l, m, L, R, D);
        if (m + 1 <= R) replace(rc, m + 1, r, L, R, D);
        pushup(k, lc, rc);
    }
    inline void increase(ll k, ll l, ll r, ll L, ll R, ll D) {
        if (l == r) { a[k].sum += (r - l + 1) * D; return; }
        ll lc = k << 1, rc = lc | 1, m = (l + r) >> 1;
        if (m >= L) increase(lc, l, m, L, R, D);
        if (m + 1 <= R) increase(rc, m + 1, r, L, R, D);
        pushup(k, lc, rc);
    }
    inline void pushup(ll k, ll lc, ll rc) {
        a[k].sum = a[lc].sum + a[rc].sum;
    }
    inline ll query(ll k, ll l, ll r, ll L, ll R) {
        if (L <= l && r <= R) return a[k].sum;
        ll lc = k << 1, rc = lc | 1, m = (l + r) >> 1, ans = 0;
        if (m >= L) ans += query(lc, l, m, L, R);
        if (m + 1 <= R) ans += query(rc, m + 1, r, L, R);
        return ans;
    }
};
```

```cpp
#include "bits/stdc++.h"
using namespace std;

using ll = long long;

struct STN { ll val, lazy; };
struct ST {
    ll mn, mx;
    vector<STN> a;
    ST(ll mn = 1, ll mx = 1e6) : mn(mn), mx(mx), a(vector<STN>((mx - mn) * 4)) {};

    void increase(ll l, ll r, ll d) { increase(1, mn, mx, l, r, d); }
    inline void increase(ll k, ll l, ll r, ll L, ll R, ll D) {
        if (L <= l && r <= R) {
            a[k].val += (r - l + 1) * D, a[k].lazy += D;
            return;
        }
        pushdown(k, l, r);
        ll lc = k << 1, rc = lc | 1, m = (l + r) >> 1;
        if (m >= L) increase(lc, l, m, L, R, D);
        if (m+1 <= R) increase(rc, m+1, r, L, R, D);
        pushup(k);
    }
    inline void pushdown(ll k, ll l, ll r) {
        auto &lazy = a[k].lazy;
        if (!lazy) return;
        ll lc = k << 1, rc = lc | 1, m = (l + r) >> 1;
        a[lc].lazy += lazy, a[lc].val += (m - l + 1) * lazy;
        a[rc].lazy += lazy, a[rc].val += (r - (m+1) + 1) * lazy;
        lazy = 0;
    }
    inline void pushup(ll k) {
        ll lc = k << 1, rc = lc | 1;
        a[k].val = a[lc].val + a[rc].val;
    }
    ll query(ll l, ll r) { return query(1, mn, mx, l, r); }
    inline ll query(ll k, ll l, ll r, ll L, ll R) {
        if (L <= l && r <= R) return a[k].val;
        pushdown(k, l, r);
        ll lc = k << 1, rc = lc | 1, m = (l + r) >> 1, ans = 0;
        if (m >= L) ans += query(lc, l, m, L, R);
        if (m+1 <= R) ans += query(rc, m+1, r, L, R);
        return ans;
    }
};

int main() {
    int n, m; cin >> n >> m;    
    ST st(1, n);
    for (int i = 1, t; i <= n; i++) cin >> t, st.increase(i, i, t);    
    while (m--) {
        int op, x, y, k; cin >> op;
        if (op == 1) {
            cin >> x >> y >> k; st.increase(x, y, k);
        } else {
            cin >> x >> y; cout << st.query(x, y) << endl;
        }
    }
}
```

åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘ï¼Œæ•°ç»„å®ç°ã€‚æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨å·¦å³å„¿å­ä¿¡æ¯ï¼Œè€Œä¸æ˜¯å¼ºåˆ¶æ ¹æ®ä¸‹æ ‡è®¡ç®—ã€‚

```cpp
#include "bits/stdc++.h"
using namespace std;

using ll = long long;
static const int mxn = 5 * 1e5;

struct STN {
    ll val, lazy, lc, rc;
    STN() : val(0), lazy(0), lc(0), rc(0) {}
};
struct ST {
    ll mn, mx, cnt;
    vector<STN> a;
    ST(ll mn = 1, ll mx = mxn) : mn(mn), mx(mx), cnt(2), a(vector<STN>(mxn * 2, STN())) {};

    ll newnode() { return cnt++; }
    void increase(ll l, ll r, ll d) {
        ll k = 1;
        increase(k, mn, mx, l, r, d);
    }
    inline void increase(ll &k, ll l, ll r, ll L, ll R, ll D) {
        if (!k) k = newnode();
        if (L <= l && r <= R) {
            a[k].val += (r - l + 1) * D, a[k].lazy += D;
            return;
        }
        pushdown(k, l, r);
        ll m = (l + r) >> 1;
        if (m >= L) increase(a[k].lc, l, m, L, R, D);
        if (R >= m+1) increase(a[k].rc, m+1, r, L, R, D);
        pushup(k);
    }
    inline void pushdown(ll &k, ll l, ll r) {
        auto &lazy = a[k].lazy;
        if (!lazy) return;
        ll &lc = a[k].lc, &rc = a[k].rc, m = (l + r) >> 1;
        if (!lc) lc = newnode();
        if (!rc) rc = newnode();
        a[lc].lazy += lazy, a[lc].val += (m - l + 1) * lazy;
        a[rc].lazy += lazy, a[rc].val += (r - (m+1) + 1) * lazy;
        lazy = 0;
    }
    inline void pushup(ll &k) {
        ll lc = a[k].lc, rc = a[k].rc;
        a[k].val = a[lc].val + a[rc].val;
    }
    ll query(ll l, ll r) {
        ll k = 1;
        return query(k, mn, mx, l, r); 
    }
    inline ll query(ll &k, ll l, ll r, ll L, ll R) {
        if (!k) return 0;
        if (L <= l && r <= R) return a[k].val;
        pushdown(k, l, r);
        ll m = (l + r) >> 1, ans = 0;
        if (m >= L) ans += query(a[k].lc, l, m, L, R);
        if (R >= m+1) ans += query(a[k].rc, m+1, r, L, R);
        return ans;
    }
};

int main() {
    int n, m; cin >> n >> m;    
    ST st(1, n);
    for (int i = 1, t; i <= n; i++) cin >> t, st.increase(i, i, t);    
    while (m--) {
        int op, x, y, k; cin >> op;
        if (op == 1) {
            cin >> x >> y >> k; st.increase(x, y, k);
        } else {
            cin >> x >> y; cout << st.query(x, y) << endl;
        }
    }
}
```

